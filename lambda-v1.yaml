AWSTemplateFormatVersion: '2010-09-09'
Description: 'CloudFormation template to create and execute a Lambda function for EKS and Helm commands'

Parameters:
  EksClusterName:
    Type: String
    Description: Name of the EKS cluster where the Helm application will be deployed
    Default: my-eks-cluster-v7
    
  EksClusterRegion:
    Type: String
    Description: Region of the EKS cluster
    Default: ap-southeast-1

Resources:
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  AwsKubectlHelmLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: aws-kubectl-helm-layer
      Description: Lambda layer containing AWS CLI, kubectl, and Helm
      Content:
        S3Bucket: !Ref S3Bucket
        S3Key: lambda-layer.zip
      CompatibleRuntimes:
        - python3.8
        - python3.9
        - python3.10

  LambdaLayerBuildFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: build-aws-kubectl-helm-layer
      Handler: index.handler
      Role: !GetAtt LambdaLayerBuildExecutionRole.Arn
      Runtime: python3.9
      Timeout: 900
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import os
          import subprocess
          import shutil

          s3 = boto3.client('s3')

          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      # Create directories
                      os.makedirs('/tmp/lambda-layer/bin', exist_ok=True)
                      os.chdir('/tmp/lambda-layer')

                      # Download and install AWS CLI
                      subprocess.run('curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"', shell=True, check=True)
                      subprocess.run('unzip awscliv2.zip', shell=True, check=True)
                      subprocess.run('./aws/install -i bin/aws-cli -b bin', shell=True, check=True)
                      shutil.rmtree('aws')
                      os.remove('awscliv2.zip')

                      # Download and install kubectl
                      subprocess.run('curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"', shell=True, check=True)
                      subprocess.run('chmod +x kubectl', shell=True, check=True)
                      shutil.move('kubectl', 'bin/')

                      # Download and install Helm
                      subprocess.run('curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3', shell=True, check=True)
                      subprocess.run('chmod 700 get_helm.sh', shell=True, check=True)
                      subprocess.run('HELM_INSTALL_DIR=bin ./get_helm.sh', shell=True, check=True)
                      os.remove('get_helm.sh')

                      # Create ZIP file
                      shutil.make_archive('/tmp/lambda-layer', 'zip', '/tmp/lambda-layer')

                      # Upload to S3
                      s3.upload_file('/tmp/lambda-layer.zip', event['ResourceProperties']['S3BucketName'], 'lambda-layer.zip')

                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  except Exception as e:
                      print(str(e))
                      cfnresponse.send(event, context, cfnresponse.FAILED, {})
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

  LambdaLayerBuildExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !Sub 'arn:aws:s3:::${S3Bucket}/*'

  EksHelmDeployFunction:
    Type: AWS::Lambda::Function
    DependsOn: AwsKubectlHelmLayer
    Properties:
      FunctionName: eks-helm-deploy
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 300
      MemorySize: 512
      Layers:
        - !Ref AwsKubectlHelmLayer
      Environment:
        Variables:
          PATH: /var/lang/bin:/usr/local/bin:/usr/bin/:/bin:/opt/bin
          KUBECONFIG: /tmp/kubeconfig
          EKS_CLUSTER_NAME: !Ref EksClusterName
          EKS_CLUSTER_REGION: !Ref EksClusterRegion
      Code:
        ZipFile: |
          import os
          import subprocess
          import boto3

          def run_command(command):
              process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True, executable='/bin/bash')
              stdout, stderr = process.communicate()
              return stdout.decode(), stderr.decode(), process.returncode

          def handler(event, context):
              cluster_name = os.environ['EKS_CLUSTER_NAME']
              region = os.environ['EKS_CLUSTER_REGION']

              # Update kubeconfig
              aws_command = f"aws eks update-kubeconfig --name {cluster_name} --region {region}"
              stdout, stderr, return_code = run_command(aws_command)
              
              if return_code != 0:
                  return {
                      'statusCode': 500,
                      'body': f'Failed to update kubeconfig: {stderr}'
                  }

              # Add Helm repo
              helm_repo_command = "helm repo add examples https://helm.github.io/examples"
              stdout, stderr, return_code = run_command(helm_repo_command)
              
              if return_code != 0:
                  return {
                      'statusCode': 500,
                      'body': f'Failed to add Helm repo: {stderr}'
                  }

              # Install Helm chart
              helm_install_command = "helm install ahoy examples/hello-world"
              stdout, stderr, return_code = run_command(helm_install_command)
              
              if return_code != 0:
                  return {
                      'statusCode': 500,
                      'body': f'Failed to install Helm chart: {stderr}'
                  }

              return {
                  'statusCode': 200,
                  'body': 'EKS kubeconfig updated and Helm chart installed successfully'
              }

  EksAdditionalRoleAccess:
      Type: AWS::EKS::AccessEntry
      Properties:
        ClusterName: !Ref EksClusterName
        PrincipalArn: !GetAtt LambdaExecutionRole.Arn
        Type: STANDARD
        AccessPolicies:
          - PolicyArn: arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy
            AccessScope:
              Type: cluster


  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy
      Policies:
        - PolicyName: EKSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - eks:DescribeCluster
                Resource: '*'

  LambdaInvoker:
    Type: Custom::LambdaInvoker
    DependsOn: EksHelmDeployFunction
    Properties:
      ServiceToken: !GetAtt LambdaInvokerFunction.Arn
      FunctionName: !Ref EksHelmDeployFunction

  LambdaInvokerFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaInvokerRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import cfnresponse
          import boto3

          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      lambda_client = boto3.client('lambda')
                      function_name = event['ResourceProperties']['FunctionName']
                      
                      response = lambda_client.invoke(
                          FunctionName=function_name,
                          InvocationType='RequestResponse'
                      )
                      
                      if response['StatusCode'] == 200:
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Message': 'Lambda function invoked successfully'})
                      else:
                          cfnresponse.send(event, context, cfnresponse.FAILED, {'Message': 'Failed to invoke Lambda function'})
                  except Exception as e:
                      cfnresponse.send(event, context, cfnresponse.FAILED, {'Message': str(e)})
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {'Message': 'Nothing to do for Delete'})

  LambdaInvokerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: InvokeLambda
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt EksHelmDeployFunction.Arn

Outputs:
  S3BucketName:
    Description: Name of the created S3 bucket
    Value: !Ref S3Bucket
  LambdaLayerArn:
    Description: ARN of the created Lambda layer
    Value: !Ref AwsKubectlHelmLayer
  LambdaFunctionArn:
    Description: ARN of the created Lambda function
    Value: !GetAtt EksHelmDeployFunction.Arn